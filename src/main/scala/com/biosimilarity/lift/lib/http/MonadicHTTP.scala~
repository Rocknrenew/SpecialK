// -*- mode: Scala;-*- 
// Filename:    MonadicAMQP.scala 
// Authors:     lgm                                                    
// Creation:    Fri Jan 21 13:10:54 2011 
// Copyright:   Not supplied 
// Description: 
// ------------------------------------------------------------------------

package com.biosimilarity.lift.lib.http

import com.biosimilarity.lift.lib.moniker._

import net.liftweb.amqp._

import scala.util.continuations._

import scala.concurrent.{Channel => Chan, _}
import scala.concurrent.cpsops._

import _root_.com.rabbitmq.client.{ Channel => RabbitChan, _}
import _root_.scala.actors.Actor

import com.thoughtworks.xstream.XStream
import com.thoughtworks.xstream.io.json.JettisonMappedXmlDriver

import org.apache.http.HttpResponse
import org.apache.http.impl.nio.client.DefaultHttpAsyncClient
import org.apache.http.nio.client.methods.HttpAsyncGet
import org.apache.http.nio.client.HttpAsyncClient
import org.apache.http.nio.concurrent.FutureCallback;

import java.io.IOException;
import java.util.concurrent.Future;

import java.net.URI
import _root_.java.io.ObjectInputStream
import _root_.java.io.ByteArrayInputStream
import _root_.java.util.Timer
import _root_.java.util.TimerTask

trait MonadicHTTPDispatcher[T]
 extends MonadicGenerators
  with FJTaskRunners {
   self : WireTap with Journalist =>          

     //  type ConnectionParameters = RabbitCnxnParams
     type Channel = BaseHttpAsyncRequestProducer
    //  type Ticket = Int
    type Payload = HttpResponse

    abstract class ResponseHandler[T](
      val httpClient : HttpAsyncClient,
      val channel : Channel
    ) extends FutureCallback[HttpResponse] {
      def completed( response : HttpResponse ) : Unit
      def failed( ex : Exception ) : Unit
      def cancelled() : Unit
    }

  override def acceptConnections(
    factory : ClientConnectionManager,
    request : String
  ) =
    Generator {
      k : ( Channel => Unit @suspendable ) => {
	//shift {
	  //innerk : (Unit => Unit @suspendable) => {	

	val httpClient = new DefaultHttpAsyncClient( factory )
	val channel = new HttpGet( string )

	k( httpClient, channel );
	  //}
	//}      
      }
    }   

  override def beginService(
    factory : ConnectionFactory,
    request : String
  ) = {
    serve [T]( factory, request )
  }

   def serve [T] (
    factory : ConnectionFactory,
    request : String
  ) = Generator {
    k : ( T => Unit @suspendable ) =>
      //shift {
	blog(
	  "The rabbit is running... (with apologies to John Updike)"
	)

	for( channel <- acceptConnections( factory, request ) ) {
	  spawn {
	    // Open bracket
	    blog( "Connected: " + channel )

            for ( t <- read [T] ( httpClient, channel ) ) { k( t ) }

            // Close bracket
	  }
	}
      //}
  }

  def callbacks( httpClient : HttpAsyncClient, channel : Channel ) =
    Generator {
      k : ( Payload => Unit @suspendable) =>

      blog("level 1 callbacks")

      shift {
	outerk : (Unit => Any) =>
	  
	  object TheRendezvous
	   extends ResponseHandler[T]( httpClient, channel ) {
    	     override def completed(
	       response : HttpResponse
	     ) {
    	       spawn { 
  		 blog("before continuation in callback")
  		
    		 k( response )
    		
    		 blog("after continuation in callback")
    		   
		 outerk()
    	       }
    	     }
	     override def failed( ex : Exception ) {
	       ex.printStackTrace()
	     }
	     override def cancelled() {
	       blog( "request cancelled" )
	     }
	   }
  	
  	blog("before registering callback")
  	
	httpClient.execute( channel, TheRendezvous )
  	
  	blog("after registering callback")
  	// stop
      }
    }   

   def read [T] ( httpClient : HttpClient, channel : Channel ) =
     Generator {
       k: ( T => Unit @suspendable) =>
	 shift {
	   outerk: (Unit => Unit) =>
	     reset {
	      
  	       for (
		 response <- callbacks( httpClient, channel )
	       ) {
		 val httpEntity = response.getEntity
		 
		 val in = new ObjectInputStream( httpEntity.getContent )
		 val t = in.readObject.asInstanceOf[T];
		 k( t )
		 // Is this necessary?
		 shift { k : ( Unit => Unit ) => k() }
  	       }
  	       
  	       blog( "readT returning" )
  	       outerk()
	     }
	 }
     }
   
 }

package usage {
/* ------------------------------------------------------------------
 * Mostly self-contained object to support unit testing
 * ------------------------------------------------------------------ */ 

object MonadicAMQPUnitTest {
}

}
